---
title: "Simulation"
author: "Yunyang Zhong, Katherin Li, Linfeng Hu"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data Generation

#### Maximum Likelihood Solution
$$
\begin{align}
& L(X_1...X_n) = \sum_{i=1}^{n} exp(-\lambda) \frac{\lambda^{X_i}}{X_i!}\\
& l(X_1...X_n) = log(L(X_1...X_n)) = -n\lambda - \sum_{i=1}^{n}log(X_i!)+log(\lambda)\sum_{i=1}^{n}X_i \\
& \frac{dl}{d\lambda} = -n + \frac{\sum_{i=1}^{n}X_i}{\lambda} \quad \longrightarrow \quad \hat{\lambda}_{MLE} = \frac{\sum_{i=1}^{n}X_i}{n}
\end{align}
$$

```{r}
set.seed(222)
x_sim <- rpois(10, 327)
x_MLE <- sum(x_sim)/10
x_MLE
```


#### Bootstrap
```{r, warning=FALSE}
set.seed(222)
x_boot <- sample(x_sim, size=10, replace = T)
boot_MLE <- mean(x_boot)
boot_MLE
```

## Simulation
```{r}
set.seed(222)
library(data.table)
result <- rbindlist(lapply(c(10, 100, 500), function(n){
  rbindlist(lapply(c(300, 330, 350), function(trueVal){
    x_pois <- rpois(n, trueVal)
    x_norm <- rnorm(n, trueVal, 20)
    
    #calculate lambda hat
    MLE_pois <- mean(x_pois)
    MLE_norm <- mean(x_norm)
    
    #calculate analytic variance
    var_pois <- sd(x_pois)^2
    var_norm <- sd(x_norm)^2
    
    # Return estimates in data table
    data.table(n = n, estimator = factor(c("Poisson", "Normal")), trueValue = trueVal,
               estimate = c(MLE_pois, MLE_norm), variances = c(var_pois, var_norm))
  }))
  }))
result
```

```{r}
# Get results from simulation
bias_sim = result[, .(mean_bias = mean(estimate - trueValue),
                           lower_bias = quantile(estimate - trueValue, 0.025),
                           upper_bias = quantile(estimate - trueValue, 0.975)),
by = c("n", "trueValue", "estimator")]

mse_sim <- result[, .(mean_mse = mean((estimate - trueValue)^2),
                          lower_mse = quantile((estimate - trueValue)^2, 0.025),
                          upper_mse = quantile((estimate - trueValue)^2, 0.975)),
                      by = c("n", "trueValue", "estimator")]

estimator_var <- result[, .(var_est = var(estimate)), by = c("n", "trueValue", "estimator")]

library(ggplot2)
library(dplyr)
# Plot of bias, facet by beta
bias_sim %>%
  ggplot(aes(x = n, y = mean_bias, color = estimator)) + 
  geom_pointrange(aes(ymin = lower_bias, ymax = upper_bias)) + geom_line(alpha = 0.2) +
  geom_point(aes(shape = factor(trueValue))) +
  geom_abline(slope = 0, intercept = 0, alpha = 0.2) + facet_wrap(~trueValue) +
  scale_shape_discrete("True value") +
  labs(x = "Sample size", y = "Mean bias") +
  theme_classic()
```

```{r}
set.seed(222)
library(data.table)
result <- rbindlist(lapply(c(10, 100, 500), function(n){
  rbindlist(lapply(c(300, 330, 350), function(trueVal){
    x_pois <- rpois(n, trueVal)
    x_norm <- rnorm(n, trueVal, 20)
    
    #calculate lambda hat
    MLE_pois <- mean(x_pois)
    MLE_norm <- mean(x_norm)
    
    #calculate analytic variance
    var_pois <- sd(x_pois)^2
    var_norm <- sd(x_norm)^2
    
    # Return estimates in data table
    data.table(n = n, estimator = factor(c("Poisson", "Normal")), trueValue = trueVal,
               estimate = c(MLE_pois, MLE_norm), variances = c(var_pois, var_norm))
  }))
  }))
result
```















#### Method of Moment Solution
Using second method to estimate $\hat \lambda$.
$$
\begin{align}
& E[X^2] = Var(X) + E[X^2] = \lambda+\lambda^2 \\
& 2nd\;sample\;moment = \frac{\sum_{i=1}^{n}X_i^2}{n}\\
\end{align}
$$

```{r}
sum(x_sim^2)/10
```




